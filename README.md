# 概要
* とらゼミの「日本一わかりやすいTypeScript入門」を学習

# 進捗
1. [概要](https://youtu.be/kd8VH10jXwc)
2. [tsconfigとWebpackの設定を理解して環境構築](https://youtu.be/qSHlXcSces8)
3. [ESLintとPrettierでコードの品質を高めよう](https://youtu.be/R35LJL6a-p0)
4. [基本の型定義とアノテーション](https://youtu.be/KQhyHHQrcic)
5. [関数のパラメーターと戻り値に型をつける](https://youtu.be/obdbskaarVQ)
6. [型エイリアス(type)でオブジェクトの型定義](https://youtu.be/2DoYdw-rvL0)
7. [積極的に使いたい配列・タプルの型定義](https://youtu.be/BUSlgsUWn4I)
8. [ジェネリック型を使いながらポリモーフィズムを理解する](https://youtu.be/5JYZzB7MMvo)
9. [TypeScriptで学ぶオブジェクト指向開発](https://youtu.be/7u8o1r0LkHU)
10. [ハンズオンで理解するInterfaceとType Aliasの違い](https://youtu.be/J2vox52T4W8)
11. [非同期処理にも型定義！APIから安全にデータを取得](https://youtu.be/7BCC4psJXqQ)

# 2.tsconfigとWebpackの設定を理解して環境構築

## 内容
  * node環境構築
  * npm initで初期化
  * パッケージのインストール
    * `--save-dev`：開発環境だけで使わないものにはこのオプション
    * `--save`：本番環境でも使う場合
  * TypeScript環境の構築
    * `$ npm i typescript -g`で`tsc`コマンドを使えるように設定
    * `$ tsc --init`で初期設定
  * Webpackの設定
    * `webpack.config.js`に設定記述(内容はファイルにコメントの記載)
  * tsconfigの設定
    * `tsconfig.json`に設定記述(内容はファイルにコメントの記載)
  * 実際に実行する(HTMLにjsから内容の表示)
    * ローカルでtsファイルをコンパイルし確認
      * `$ npm run start`
    * tsファイルをビルド
      * `$ npm run build`

## メモ
### Webpack
  * 依存関係を考慮しながら1つのJSファイルにまとめる(バンドル)
### TypeScript
  * コンパイラでTSをJSに変換
### ts-loader(パッケージ)
  * Webpackと連動してTSコンパイラを起動
### webpack-cli
  * コマンドラインでwebpackを使う
### webpack-dev-server
  * 開発環境でWebpackのビルド
  * 開発用Webサーバーの起動
  * ホットリロード

# 3.ESLintとPrettierでコードの品質を高めよう

## 内容
  * パッケージのインストール
  * prettierの設定
    * `printWidth`：1行にどれだけの文字を入れるか
    * `singleQuote`：シングルクォート使用時とかのバグチェック
    * `semi`：文末にセミコロンをつけるかどうか
  * ESLintの設定
    * `prettier`：`extends`に最後に記載
    * `parser`：`TypeScript`を解析するparserを指定
    * `parserOptions`：tsconfig.jsonの設定値を見るように
    * `root`：このファイルがルートというのを明示
  * `husky` + `ESLint`&`Prettier`でGitコミット(フックの設定をpackage.jsonに記載)
    * `$ git commit`を行う
    * `husky`実行
    * `pre-commit hook`実行
    * `lint-staged`呼び出し
    * `ESLint`と`Prettier`実行
    * `Git`にアップ

## メモ
### ESLint
  * JSの検証ツール、コーディングスタイルの一貫性を維
### Prettier
  * コードフォーマッター、プロジェクトごとにルールを設定し、コードを整形できる
### eslint-config-prettier
  * `eslint`と`prettier`を併用する際に設定を反映させる
### @typescript-eslint/eslint-plugin
  * ESLintでTypeScriptのチェックを行うプラグイン
### @typescript-eslint/parser
  * ESLintでTypeScriptを解析するプラグイン
### husky
  * Gitコマンドをフックに別のコマンドを実行させるためのパッケージ
### lint-staged
  * コミットしたファイルにlintを実行する
### パス指定の`**`
  * 階層もワイルドカードで指定できる
### VSCodeのESLintで.eslintrc.jsのエラーの対処
  * [参考サイト](https://wonwon-eater.com/ts-eslint-import-error/)



# 4.基本の型定義とアノテーション

## 内容
  * 型推論と明示的な形定義
    * TypeScriptは型を勝手に決める
      * `const name = 'string'` -> `string`型！
    * 明示的に型を書くこともできる
      * `const name: string = 'string'` -> `string`型！
  * プリミティブ型
    * 文字列`string`：`const name: string = 'string'`
    * 正数/負数`number`：`const age: number = 25`
    * 真偽直`boolean`：`const isOver20: boolean = true`
      * 判定式でも使える
  * 存在しないことを表現する
    * `null`：初期化されているけど(変数はあるけど)直が入っていない状態
    * `undefined`：初期化すらされていない
    * できる限り`undefined`を使う
  * TypeScriptはanyを回避する
    * `any`：なんの型でもいい -> なるべく使わない
    * `unknown`：どんな型になるのか不明
      * `unknown`は代入した直で型が変化



# 5.関数のパラメーターと戻り値に型をつける

## 内容
  * 関数で使われる型
    * `void`：return文を持たない関数の戻り値
    * `never`：戻ることのない関数の戻り値
  * オプションとデフォルト
    * `オプションパラメーター`
      * パラメータの最後に記述する(複数可)
      * オプショナルを示す`?`をつける
    * `デフォルトパラメーター`
      * パラメーターの順序関係なく記述可能
      * `=`で指定する(PHPに似てる)
  * 可変長引数に型をつける
    * `可変長引数`とは？
      * 関数の呼び出しの際に引数の数が自由
      * 型が安全ではない -> `×`
    * レストパラメーター
      * パラメーターに`...`を用いることで型定義可能
      * パラメーターの最後に1つだけ指定可能
  * 呼び出しシグネチャ
    * シグネチャ：`関数名`、`引数の数`、`データ型`、`戻り値の型`のことをいう
    * どのような関数なのか表現する型定義
    * 省略記法はアロー関数に似ている
    * 完全な記法はオブジェクトと似た形
    * Reactの関数コンポーネントとかでよく使う

# 6.型エイリアス(type)でオブジェクトの型定義

## 内容
  * object型には意味はない
    * object型はおべじぇctであることを伝えるだけ
    * オブジェクトリテラル記法を使おう
      * 構造を定義
      * 各プロパティに型
  * 特別なプロパティ
    * オプショナル(`?`)のついたプロパティはあってもなくてもOK
    * `readonly`のついたプロパティは上書きできない
  * オブジェクトの柔軟な型定義
    * インデックスシグネチャ
      * オブジェクトが複数のプロパティを持つ可能性を示す
      * keyはstringかnumberのみ
  * 型エイリアスで型定義を再利用
    * 型エイリアスとは
      * typeを使って、型に名前をつけて宣言できる
      * 同じ型を何度も定義する必要がない
      * 形に名前をつけることで変数の役割を明確化
  * 合併型(union)と交差型(intersection)
    * 合併型：型Aか型Bどちらかの型を持つ
    * 交差型：型Aと型B両方の型を持つ  
      ※「AとBに`共通する型ではない`」

# 7.積極的に使いたい配列・タプルの型定義

## 内容
  * 配列に秩序をもたらす型定義
    * 配列の要素として持つ値の型を定義できる
    * 型定義方法`T[]`と`Array<T>`は同じ
    * 合併型も使える(特別な理由がない限りは使わない方が良き)
  * 配列の型推論
    * アノテーションしなくても型推論される
  * 厳格な配列 = タプル
    * タプルは配列の各要素の数と型を定義できる
    * 可変長(レストパラメーター)も使える
  * イミュータブルな配列(`イミュータブル`：変更できない)
    * jsの配列はconstで宣言してもミュータブル(書き換え可)
    * `readonly`修飾子でイミュータブル(書き換え不可)な配列/タプルを使える

# 8.ジェネリック型を使いながらポリモーフィズムを理解する

## 内容
  * 型を抽象化するジェネリック型
    * 肩の種類は異なるが同じデータの構造を共通化させる
    * `ジェネリック型パラメーター`
      * 型をパラメーター化(後から日パラメーターを渡す)
      * `T` / `U` / `V` / `W`などがよく使われる
  * ジェネリックの宣言方法
    * 「呼び出しシグネチャの記法」と「ジェネリック型の割り当て範囲」によって異なる
  * 呼び出し側の共通化
    * `ポリモーフィズム`：色々な形に変化できること
    * ジェネリック型を用いると
      * 型を抽象化して共通化できる
      * 呼び出す時に具体的な型を渡す

# 9.TypeScriptで学ぶオブジェクト指向開発

## 内容
  * オブジェクト指向は再利用のために使う
    * `クラス`の3つの役割
      * `まとめる`：ある機能についてデータと振る舞いをまとめる
      * `隠す`：外部から参照・改変できないようにする
      * `たくさん作る`：同じ機能を持つクローンを量産できる(`インスタンス`)
  * 用語の整理
    * `プロパティ`：クラスが持つデータ。フィールドメンバ変数とも呼ばれる
    * `メソッド`：クラスで宣言する関数のこと
    * `コンストラクタ`：クラスからインスタンスを作る時に行う初期化
    * `インスタンス`：クラスから作られたオブジェクト、クラスの機能を持つ
    * `private`：そのクラスでのみアクセス可能
    * `protected`：そのクラスとサブクラスでのみアクセス可能
    * `public`：どこからでもアクセス可能(デフォルト)
  * 将棋でクラス化の練習
    * ディレクトリ名「`oop`」：`オブジェクト指向プログラミング`「Object Oriented Programming」略
    * 駒の位置をクラス化
  * 抽象クラスはインスタンス化できない
    * 抽象クラス(`abstract`修飾子の着いたクラス)
      * 抽象クラスはインスタンス化できない
      * 継承でサブクラスを作るためのクラス
        * ここでは`Pieceクラス`ではどの駒か具体的なことが記載されていないため抽象的すぎる
        * `Piece(駒)クラス`を`継承`した`Osho(王将)クラス`のようなものがあればより具体的な駒のクラスとして使用が可能になる！
        * `Osho(王将)クラス`の内容を`Piece(駒)クラス`の書けばいいことだが、そうすると`Piece(駒)クラス`が肥大化し再利用性が失われる

# 10.ハンズオンで理解するInterfaceとType Aliasの違い

## 内容
  * Type AliasとInterfaceの誤読
    * 型エイリアス(type)の方が機能が少ない
      * 2021年時点のバージョンでは大差なし
    * 全てのソフトウェアは拡張的であるべきなのでInterfaceを使うべき
      * ライブラリ：不特的多数が利用するので`拡張性を持つべき`
      * アプリケーション：全ての型で拡張性を持つと`バグを生む`
  * Interfaceの基本用法と宣言のマージ
    * `interface`宣言子で定義
    * Type Aliasと違って`=`は不要(`class`に似ている)
    * 同名のinterfaceを宣言すると`型が追加(マージ)`される
    * 宣言のマージ：複数の宣言を自動的に結合
  * Interfaceの拡張
    * extendsを使うことで継承したサブインターフェースを作れる
    * `Type Alias`を`extends`することもできる
  * Interfaceでclassに型を定義する
    * `implements`を使ってclassに型を定義できる
  * `Type Alias`と`Interface`の違いまとめ  

|    |  Type Alias  |  Interface  |
| :----: | ---- | ---- |
|  用途  |  複数の場所で再利用する型に名前をつけるため  |  オブジェクト・クラス・関数の構造を定義するため  |
|  拡張性  |  同名のtypeを宣言するとエラー  |  同名のinterfaceを線芸するとマージ  |
|  継承  |  継承はできない・交差型で新しい型エイリアスを作る  |  extendsで継承ができる  |
|  使用できる型  |  オブジェクトや型以外、プリミティブ、配列、タプルも宣言可能  |  オブジェクトと関数の型のみ宣言できる  |
|  考慮事項  |  拡張しにくい不便さがある  |  拡張できることによりバグを生む可能性  |
|  いつ使う  |  アプリ開発ではType Alias  |  ライブラリ開発ではInterface  |

`※いつ使うの部分はケースバイケース`

# 10.非同期処理にも型定義！APIから安全にデータを取得

## 内容
  * そもそも非同期処理とは
    * 通信が発生する処理で起きる
      * Web APIを叩く
      * データベースへクエリを投げる
    * 実行完了を待たず次の処理に進む
    * JSはシングルスレッドの言語
      * 非同期APIにより効率よく処理を行うことが可能
  * 非同期処理は一長一短
    * `良`：複数の処理を並行して効率よく実行できる
      * 重い処理や時間のかかる通信中にユーザーに別の操作を許可するなど
    * `悪`：制御が難しい
      * 処理が実行中なのか実行完了したのかトレースしにくい
    * どう対処すべき
      * Promiseやaysnc/awaitで非同期処理を同期的に制御する
      * 型をつけることでよりわかりやすく！ 
  * Promise型で実行完了後の値を定義する
    * 非同期処理の実行結果は`Promise<string>`のように定義できる
    * Promiseの状態
      * `Promise<pending>`：初期状態 / 実行中
      * `Promise<fulfilled>`：処理が成功して完了した状態
      * `Promise<rejected>`：処理が失敗して完了した状態